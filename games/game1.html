<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ç•‘ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ãƒ€ãƒ¼ï¼ˆInvaders for Cropsï¼‰</title>
  <style>
    :root{ color-scheme: light dark; }
    html,body { height: 100%; margin: 0; background:#0b1d0b; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;}
    #wrap { display:flex; flex-direction:column; height:100%; }
    header { padding: 8px 12px; color:#e8ffe8; background:#103410; font-weight:600; font-size:14px; display:flex; justify-content:space-between; align-items:center; }
    header .btn { appearance:none; border:1px solid #4faa4f; color:#e8ffe8; background:#165c16; padding:6px 10px; border-radius:6px; font-size:12px; }
    #game { flex:1; display:flex; align-items:center; justify-content:center; }
    canvas { width: 100vw; height: calc(100vh - 120px); max-height: calc(100vh - 120px); touch-action: none; background: linear-gradient(#0b1d0b, #0a240a 60%, #073007); }
    /* ç”»é¢ä¸‹ã®ã‚¿ãƒƒãƒã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ© */
    #controls { height: 100px; display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; padding: 8px 12px; background:#0d250d; }
    .ctl { user-select:none; -webkit-user-select:none; touch-action: manipulation; display:flex; align-items:center; justify-content:center; border-radius:12px; font-size:22px; color:#e8ffe8; background:#134013; border:2px solid #2f7a2f; }
    .ctl:active { transform: scale(0.98); filter: brightness(1.15); }
    /* HUD */
    #hud { position: fixed; top: 44px; left: 8px; right: 8px; display:flex; justify-content:space-between; color:#e8ffe8; font-size:12px; pointer-events:none; text-shadow: 0 1px 0 #000;}
    /* ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã§ã¯ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚’å°‘ã—ä½ã */
    @media (min-width: 840px) {
      canvas { height: calc(100vh - 110px); }
      #controls { height: 80px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <header>
      <div>ğŸ¥¬ ç•‘ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ãƒ€ãƒ¼ - å®³è™«ã‹ã‚‰ä½œç‰©ã‚’å®ˆã‚ã†ï¼</div>
      <div>
        <button id="btnPause" class="btn">â¸ ä¸€æ™‚åœæ­¢</button>
        <button id="btnRestart" class="btn">â†» ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
      </div>
    </header>

    <div id="hud">
      <div id="hudLeft">ã‚¹ã‚³ã‚¢: 0 / ã‚¦ã‚§ãƒ¼ãƒ–: 1</div>
      <div id="hudRight">ä½œç‰©HP: 3</div>
    </div>

    <div id="game">
      <canvas id="cv" width="900" height="600" aria-label="game canvas"></canvas>
    </div>

    <div id="controls">
      <button class="ctl" id="leftBtn">â—€</button>
      <button class="ctl" id="fireBtn">â—</button>
      <button class="ctl" id="rightBtn">â–¶</button>
    </div>
  </div>

  <script>
  // ====== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ======
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const hudL = document.getElementById('hudLeft');
  const hudR = document.getElementById('hudRight');
  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');

  // ãƒ‡ãƒã‚¤ã‚¹ãƒ”ã‚¯ã‚»ãƒ«æ¯”ã«åˆã‚ã›ã¦é«˜è§£åƒåº¦åŒ–
  function fitCanvas() {
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    // å¯è¦–é ˜åŸŸã«åˆã‚ã›ã¦ã‚¢ã‚¹ãƒšã‚¯ãƒˆèª¿æ•´ï¼ˆæ¨ªé•·ã«å¯„ã›ã‚‹ï¼‰
    const cssW = window.innerWidth;
    const cssH = Math.max(220, window.innerHeight - 120);
    cv.style.width = cssW + 'px';
    cv.style.height = cssH + 'px';
    cv.width = Math.floor(cssW * dpr);
    cv.height = Math.floor(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // ====== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ======
  const State = {
    running: true,
    score: 0,
    wave: 1,
    cropsHP: 3,
    lastShot: 0,
    shotCooldown: 200, // ms
    lastTime: 0
  };

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
  const player = {
    x: 200, y: 0, w: 44, h: 18, speed: 360, color: '#aef39a', vx: 0
  };

  // å¼¾ãƒ»æ•µ
  const bullets = [];
  const enemies = [];
  let enemyDir = 1;      // 1:å³ -1:å·¦
  let enemySpeed = 40;   // æ°´å¹³ã‚¹ãƒ”ãƒ¼ãƒ‰
  let enemyStep = 18;    // ç«¯åˆ°é”æ™‚ã®ä¸‹é™é‡

  // åˆæœŸé…ç½®
  function resetGame() {
    State.running = true;
    State.score = 0;
    State.wave = 1;
    State.cropsHP = 3;
    enemyDir = 1;
    enemySpeed = 40;
    createWave(State.wave);
    centerPlayer();
  }

  function centerPlayer() {
    player.x = (cv.clientWidth - player.w) / 2;
    player.y = cv.clientHeight - 80;
    player.vx = 0;
  }

  function createWave(wave) {
    enemies.length = 0;
    bullets.length = 0;
    const cols = Math.min(8, 5 + Math.floor(wave * 0.8));
    const rows = Math.min(5, 2 + Math.floor(wave * 0.6));
    const marginX = 40, marginY = 50, gapX = 48, gapY = 36;
    const startX = (cv.clientWidth - (cols-1)*gapX) / 2;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        enemies.push({
          x: startX + c * gapX,
          y: marginY + r * gapY,
          w: 28, h: 18,
          type: r % 3, // 0:ã‚¢ãƒ–ãƒ©ãƒ ã‚·,1:ãƒ¨ãƒˆã‚¦,2:ãƒãƒƒã‚¿é¢¨
          alive: true
        });
      }
    }
    // é›£æ˜“åº¦èª¿æ•´
    enemySpeed = 40 + (wave-1) * 10;
  }

  // ====== å…¥åŠ›ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ»ã‚¿ãƒƒãƒï¼‰ ======
  const keys = { left:false, right:false, fire:false };

  window.addEventListener('keydown', (e)=>{
    if (e.repeat) return;
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    if (e.key === ' ' || e.key === 'Enter') keys.fire = true;
  });
  window.addEventListener('keyup', (e)=>{
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    if (e.key === ' ' || e.key === 'Enter') keys.fire = false;
  });

  // ãƒ¢ãƒã‚¤ãƒ«ãƒœã‚¿ãƒ³
  function bindButton(btn, on, off) {
    const start = (ev)=>{ ev.preventDefault(); on(); };
    const end   = (ev)=>{ ev.preventDefault(); off(); };
    btn.addEventListener('touchstart', start, {passive:false});
    btn.addEventListener('touchend', end, {passive:false});
    btn.addEventListener('touchcancel', end, {passive:false});
    btn.addEventListener('mousedown', start);
    btn.addEventListener('mouseup', end);
    btn.addEventListener('mouseleave', end);
  }
  bindButton(document.getElementById('leftBtn'),
    ()=>{ keys.left = true; },
    ()=>{ keys.left = false; }
  );
  bindButton(document.getElementById('rightBtn'),
    ()=>{ keys.right = true; },
    ()=>{ keys.right = false; }
  );
  bindButton(document.getElementById('fireBtn'),
    ()=>{ keys.fire = true; },
    ()=>{ keys.fire = false; }
  );

  // ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•ã€ã‚¿ãƒƒãƒ—ã§ã‚·ãƒ§ãƒƒãƒˆ
  let dragging = false, dragOffsetX = 0;
  cv.addEventListener('pointerdown', (e)=>{
    const rect = cv.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    if (py > player.y - 40 && py < player.y + 60) {
      dragging = true;
      dragOffsetX = px - player.x;
    } else {
      tryFire();
    }
  });
  window.addEventListener('pointermove', (e)=>{
    if (!dragging) return;
    const rect = cv.getBoundingClientRect();
    const px = e.clientX - rect.left;
    player.x = Math.max(8, Math.min(cv.clientWidth - player.w - 8, px - dragOffsetX));
  });
  window.addEventListener('pointerup', ()=> dragging = false);

  // ====== ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªï¼ˆåŠ¹æœéŸ³ã¯åˆå›æ“ä½œã§è§£ç¦ï¼‰ ======
  let audioCtx = null;
  function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  function beep(freq=600, len=0.06, vol=0.05) {
    if (!audioCtx) return;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.stop(audioCtx.currentTime + len);
  }
  window.addEventListener('pointerdown', initAudio, {once:true});

  // ====== ä¸»è¦å‡¦ç† ======
  function tryFire() {
    const now = performance.now();
    if (now - State.lastShot < State.shotCooldown) return;
    State.lastShot = now;
    bullets.push({ x: player.x + player.w/2 - 2, y: player.y - 6, w:4, h:10, vy:-520, color:'#9cf' });
    beep(760, 0.05, 0.03);
  }

  function update(dt) {
    if (!State.running) return;

    // å…¥åŠ›ã‹ã‚‰é€Ÿåº¦
    player.vx = 0;
    if (keys.left)  player.vx -= player.speed;
    if (keys.right) player.vx += player.speed;
    if (keys.fire)  tryFire();

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•
    player.x += player.vx * dt;
    player.x = Math.max(8, Math.min(cv.clientWidth - player.w - 8, player.x));

    // å¼¾æ›´æ–°
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.y += b.vy * dt;
      if (b.y + b.h < 0) bullets.splice(i,1);
    }

    // æ•µã®æ¨ªç§»å‹•ã¨ç«¯ãƒã‚§ãƒƒã‚¯
    let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
    const aliveList = enemies.filter(e => e.alive);
    aliveList.forEach(e => {
      e.x += enemyDir * enemySpeed * dt;
      minX = Math.min(minX, e.x);
      maxX = Math.max(maxX, e.x + e.w);
      maxY = Math.max(maxY, e.y + e.h);
    });
    if (aliveList.length > 0) {
      if (minX < 8 || maxX > cv.clientWidth - 8) {
        enemyDir *= -1;
        aliveList.forEach(e => e.y += enemyStep);
      }
      // ä¸‹åˆ°é”ã§ä½œç‰©HPæ¸›å°‘
      if (maxY >= player.y - 10) {
        State.cropsHP -= 1;
        beep(220, 0.2, 0.05);
        // ãƒªã‚»ãƒƒãƒˆçš„ã«å°‘ã—æˆ»ã™
        aliveList.forEach(e => e.y -= 40);
        if (State.cropsHP <= 0) {
          gameOver();
        }
      }
    }

    // å½“ãŸã‚Šåˆ¤å®šï¼ˆå¼¾Ã—æ•µï¼‰
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      for (let j = 0; j < enemies.length; j++) {
        const e = enemies[j];
        if (!e.alive) continue;
        if (b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
          e.alive = false;
          bullets.splice(i,1);
          State.score += 10;
          beep(520, 0.07, 0.04);
          break;
        }
      }
    }

    // å…¨æ»… â†’ æ¬¡ã‚¦ã‚§ãƒ¼ãƒ–
    if (enemies.every(e => !e.alive)) {
      State.wave += 1;
      createWave(State.wave);
      beep(880, 0.12, 0.05);
    }

    // HUD æ›´æ–°
    hudL.textContent = `ã‚¹ã‚³ã‚¢: ${State.score} / ã‚¦ã‚§ãƒ¼ãƒ–: ${State.wave}`;
    hudR.textContent = `ä½œç‰©HP: ${State.cropsHP}`;
  }

  function draw() {
    // èƒŒæ™¯ï¼ˆç•‘ã®æ¨ªç­‹ï¼‰
    const w = cv.clientWidth, h = cv.clientHeight;
    ctx.clearRect(0,0,w,h);
    for (let y=0; y<h; y+=20){
      ctx.fillStyle = (y%40===0) ? '#0a2b0a' : '#0b300b';
      ctx.fillRect(0,y,w,20);
    }
    // ä½œç‰©ï¼ˆå®ˆã‚‹ãƒ©ã‚¤ãƒ³ï¼‰
    ctx.fillStyle = '#2fdc5c';
    ctx.fillRect(0, player.y + player.h + 12, w, 6);

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆæ•£å¸ƒãƒ‰ãƒ­ãƒ¼ãƒ³é¢¨ï¼‰
    drawPlayer(player);

    // å¼¾
    bullets.forEach(b=>{
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x, b.y, b.w, b.h);
    });

    // æ•µï¼ˆå®³è™«ã‚’ç°¡æ˜“ã‚·ã‚§ã‚¤ãƒ—ã§æç”»ï¼‰
    enemies.forEach(e=>{
      if (!e.alive) return;
      drawBug(e);
    });

    // ãƒãƒ¼ã‚ºè¡¨ç¤º
    if (!State.running) {
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#e8ffe8';
      ctx.font = 'bold 28px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(State.cropsHP<=0 ? 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼' : 'ãƒãƒ¼ã‚ºä¸­', w/2, h/2 - 10);
      ctx.font = '16px system-ui, sans-serif';
      ctx.fillText('â†» ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã§å†é–‹ã§ãã¾ã™', w/2, h/2 + 18);
    }
  }

  function drawPlayer(p){
    ctx.save();
    ctx.translate(p.x, p.y);
    // æœ¬ä½“
    ctx.fillStyle = '#aef39a';
    ctx.fillRect(0, 0, p.w, p.h);
    // ãƒã‚ºãƒ«
    ctx.fillStyle = '#c2ffd2';
    ctx.fillRect(p.w/2 - 2, -8, 4, 8);
    // è»Šè¼ª
    ctx.fillStyle = '#214421';
    ctx.fillRect(6, p.h, 8, 6);
    ctx.fillRect(p.w-14, p.h, 8, 6);
    ctx.restore();
  }

  function drawBug(e){
    ctx.save();
    ctx.translate(e.x, e.y);
    // ç¨®åˆ¥ã”ã¨ã«è‰²ã¨å½¢ã‚’å°‘ã—å¤‰ãˆã‚‹
    if (e.type === 0) { // ã‚¢ãƒ–ãƒ©ãƒ ã‚·é¢¨
      ctx.fillStyle = '#b2ff66';
      roundedRect(0,0,e.w,e.h,6);
      ctx.fill();
      eye(6,6); eye(e.w-12,6);
    } else if (e.type === 1) { // ãƒ¨ãƒˆã‚¦ãƒ ã‚·é¢¨
      ctx.fillStyle = '#88e05a';
      roundedRect(0,0,e.w,e.h,8);
      ctx.fill();
      ctx.fillStyle='#2a4';
      ctx.fillRect(4, e.h-4, e.w-8, 3);
    } else { // ãƒãƒƒã‚¿é¢¨
      ctx.fillStyle = '#66cc55';
      ctx.beginPath();
      ctx.moveTo(0, e.h); ctx.lineTo(e.w*0.3, 2); ctx.lineTo(e.w*0.7, 2); ctx.lineTo(e.w, e.h); ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function roundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }
  function eye(x,y){
    ctx.fillStyle = '#0a250a';
    ctx.fillRect(x,y,4,4);
  }

  function gameOver(){
    State.running = false;
  }

  // ãƒ«ãƒ¼ãƒ—
  function loop(t){
    if (!State.lastTime) State.lastTime = t;
    const dt = Math.min(0.033, (t - State.lastTime) / 1000);
    State.lastTime = t;
    if (State.running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ãƒœã‚¿ãƒ³
  btnPause.addEventListener('click', ()=>{
    State.running = !State.running;
    btnPause.textContent = State.running ? 'â¸ ä¸€æ™‚åœæ­¢' : 'â–¶ å†é–‹';
  });
  btnRestart.addEventListener('click', ()=>{
    resetGame();
    State.running = true;
    btnPause.textContent = 'â¸ ä¸€æ™‚åœæ­¢';
  });

  // é–‹å§‹
  resetGame();
  </script>
</body>
</html>
